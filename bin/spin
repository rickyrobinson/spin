#!/usr/bin/env ruby
# Spin will speed up your autotest(ish) workflow for Rails.

# Spin preloads your Rails environment for testing, so you don't load the same code over and over and over... Spin works best with an autotest(ish) workflow.

require 'socket'
# This brings in `Dir.tmpdir`
require 'tempfile'
# This lets us hash the parameters we want to include in the filename
# without having to worry about subdirectories, special chars, etc.
require 'digest/md5'
# So we can tell users how much time they're saving by preloading their
# environment.
require 'benchmark'
require 'optparse'
require 'pathname'

SEPARATOR = '|'

DEFAULT_DIRS = {
  :rspec => "spec",
  :cucumber => "features",
  :testunit => "test"
}

trap('INT') do
  puts "Goodbye from Spin!"
  exit
end

def usage
  <<-USAGE
Usage: spin serve
       spin rspec|cucumber|testunit <file> <file>...
Spin preloads your Rails environment to speed up your autotest(ish) workflow.
  USAGE
end

def socket_file
  key = Digest::MD5.hexdigest [Dir.pwd, 'spin-gem'].join
  [Dir.tmpdir, key].join('/')
end

def determine_test_frameworks(force_rspec, force_testunit, force_cucumber)
  tf = []
  tf.push :rspec if force_rspec
  tf.push :cucumber if force_cucumber
  tf.push :testunit if force_testunit
  tf.push :rspec if tf.empty? && defined?(RSpec)
  tf.push :testunit if tf.empty?
  tf
end

def disconnect(connection)
  connection.print "\0"
  connection.close
end

def rails_root
  path = Pathname.pwd
  until path.join('config/application.rb').file?
    return if path.root?
    path = path.parent
  end
  path
end

# ## spin serve
def serve(test_frameworks = [], time, push_results)
  root_path = rails_root and Dir.chdir(root_path)
  file = socket_file

  # We delete the tmp file for the Unix socket if it already exists. The file
  # is scoped to the `pwd`, so if it already exists then it must be from an
  # old run of `spin serve` and can be cleaned up.
  File.delete(file) if File.exist?(file)

  # This socket is how we communicate with `spin push`.
  socket = UNIXServer.open(file)

  ENV['RAILS_ENV'] = 'test' unless ENV['RAILS_ENV']

  if root_path
    sec = Benchmark.realtime {
      # We require config/application because that file (typically) loads Rails
      # and any Bundler deps, as well as loading the initialization code for
      # the app, but it doesn't actually perform the initialization. That happens
      # in config/environment.
      #
      # In my experience that's the best we can do in terms of preloading. Rails
      # and the gem dependencies rarely change and so don't need to be reloaded.
      # But you can't initialize the application because any non-trivial app will
      # involve it's models/controllers, etc. in its initialization, which you
      # definitely don't want to preload.
      require File.expand_path 'config/application'
      
      puts "Spin serve loading test frameworks: #{test_frameworks.join(' ')}"

      # Preload RSpec and cucumber to save some time on each test run
      begin
        require 'rspec/rails'
        
        # We need to disable autorun, otherwise RSpec tries to run again on root dir after child proc exits.
        RSpec::Core::Runner.disable_autorun!

        # Tell RSpec it's running with a tty to allow colored output
        if RSpec.respond_to?(:configure)
          RSpec.configure do |c|
            c.tty = true if c.respond_to?(:tty=)
          end
        end
      rescue LoadError
      end if test_frameworks.include? :rspec

      begin
        require 'cucumber/rspec/disable_option_parser'
        require 'cucumber/cli/main'
      rescue LoadError
      end if test_frameworks.include? :cucumber
    }
    # This is the amount of time that you'll save on each subsequent test run.
    puts "Preloaded Rails env in #{sec}s..."
  else
    warn "Could not find config/application.rb. Are you running this from the root of a Rails project?"
  end

  puts "Pushing test results back to push processes" if push_results

  loop do

    # Since `spin push` reconnects each time it has new files for us we just
    # need to accept(2) connections from it.
    conn = socket.accept
    # This should be a list of relative paths to files.
    files = conn.gets.chomp
    files = files.split(SEPARATOR)
    
    test_framework = files.shift.to_sym
    
    
    files << DEFAULT_DIRS[test_framework.to_sym] if files.empty?
    
    # If we're not going to push the results,
    # Trap SIGQUIT (Ctrl+\\) and re-run the last files that were
    # pushed.
    if !push_results
      trap('QUIT') do
        fork_and_run(@last_files_ran, push_results, test_framework, nil)
        # See WAIT below
        Process.wait
      end
    end

    # If spin is started with the time flag we will track total execution so
    # you can easily compare it with time rspec spec for example
    start = Time.now if time

    # If we're not sending results back to the push process, we can disconnect
    # it immediately.
    disconnect(conn) unless push_results

    fork_and_run(files, push_results, test_framework, conn)

    # WAIT: We don't want the parent process handling multiple test runs at the same
    # time because then we'd need to deal with multiple test databases, and
    # that destroys the idea of being simple to use. So we wait(2) until the
    # child process has finished running the test.
    Process.wait

    # If we are tracking time we will output it here after everything has
    # finished running
    puts "Total execution time was #{Time.now - start} seconds" if start

    # Tests have now run. If we were pushing results to a push process, we can
    # now disconnect it.
    begin
      disconnect(conn) if push_results
    rescue Errno::EPIPE
      # Don't abort if the client already disconnected
    end
  end
ensure
  File.delete(file) if file && File.exist?(file)
end

def fork_and_run(files, push_results, test_framework, conn)
  # We fork(2) before loading the file so that our pristine preloaded
  # environment is untouched. The child process will load whatever code it
  # needs to, then it exits and we're back to the baseline preloaded app.
  fork do
    # To push the test results to the push process instead of having them
    # displayed by the server, we reopen $stdout/$stderr to the open
    # connection.
    if push_results
      $stdout.reopen(conn)
      $stderr.reopen(conn)
    end

    puts
    puts "Running #{test_framework.to_s} #{files.join(' ')}"

    if test_framework == :rspec
      RSpec::Core::Runner::run(files + ['-c'], $stderr, $stdout)
    elsif test_framework == :cucumber
      Cucumber::Cli::Main.execute(files)
    else
      # We require the full path of the file here in the child process.
      files.each { |f| require File.expand_path f }
    end

  end
  @last_files_ran = files
  @last_framework = test_framework
end

# ## spin push
def push(push_framework, files_to_load)

  # We build a string like `file1.rb|file2.rb` and pass it up to the server.
  files_to_load.map! do |file|
    args = file.split(':')

    file_name = args.first.to_s
    line_number = args.last.to_i

    # If the file exists then we can push it up just like it is
    file_name = if File.exist?(file_name)
                  file_name
                # kicker-2.5.0 now gives us file names without extensions, so we have to try adding it
                elsif File.extname(file_name).empty?
                  full_file_name = [file_name, 'rb'].join('.')
                  full_file_name if File.exist?(full_file_name)
                end

    if line_number > 0
      abort "You specified a line number. Only one file can be pushed in this case." if files_to_load.length > 1

      "#{file_name}:#{line_number}"
    else
      file_name
    end
  end.compact.uniq

  if root_path = rails_root
    files_to_load.map! do |file|
      Pathname.new(file).expand_path.relative_path_from(root_path).to_s
    end
    Dir.chdir root_path
  end

  f = [push_framework.to_s]
  f += files_to_load

  # This is the other end of the socket that `spin serve` opens. At this point
  # `spin serve` will accept(2) our connection.
  socket = UNIXSocket.open(socket_file)
  # We put the filenames on the socket for the server to read and then load.
  socket.puts f.join(SEPARATOR)

  while line = socket.readpartial(100)
    break if line[-1,1] == "\0"
    print line
  end
rescue Errno::ECONNREFUSED
  abort "Connection was refused. Have you started up `spin serve` yet?"
end

load_rspec = false
load_testunit = false
load_cucumber = false
framework_set = false
push_framework = :rspec

time = false
push_results = false
options = OptionParser.new do |opts|
  opts.banner = usage
  opts.separator ""
  opts.separator "Serve Options:"

  opts.on("-I", "--load-path=DIR#{File::PATH_SEPARATOR}DIR", "Appends directory to $LOAD_PATH") do |dirs|
    $LOAD_PATH.concat(dirs.split(File::PATH_SEPARATOR))
  end

  opts.on('-r', '--rspec', 'Load RSpec support') do |v|
    load_rspec = v
  end

  opts.on('-c', '--cucumber', 'Load Cucumber support') do |v|
    load_cucumber = v
  end

  opts.on('-u', '--test-unit', 'Load Test::Unit support') do |v|
    load_testunit = v
  end

  opts.on('-t', '--time', 'See total execution time for each test run') do |v|
    time = v
  end

  opts.on('-p', '--push-results', 'Push test results to the push process') do |v|
    push_results = v
  end

  opts.separator ""
  opts.separator "Push Options:"

  opts.separator "General Options:"
  opts.on('-e', 'Stub to keep kicker happy')
  opts.on('-h', '--help') do
    $stderr.puts opts
    exit 1
  end
end
options.parse!

subcommand = ARGV.shift
case subcommand
when 'serve' then serve(determine_test_frameworks(load_rspec, load_testunit, load_cucumber), time, push_results)
when 'rspec', 'cucumber', 'testunit' then push(subcommand.to_sym, ARGV)
else
  $stderr.puts options
  exit 1
end

